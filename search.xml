<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用七牛云存储搭建图床]]></title>
    <url>%2F2018%2F09%2F07%2F%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[为什么需要图床&emsp;&emsp;使用markdown写文章，注重的是文章的文字和排版，但是有时难免会用到图片，如果是别的站点的图片，可能源站点设置图片的防盗链，而且源站点删除了图片，自己就遭殃了，如果是自己的图片，上传到自己购买的服务器上，还不如第三方图床，速度和功能上第三方都进行过升级优化。 七牛云&emsp;&emsp;七牛云官方地址：https://portal.qiniu.com&emsp;&emsp;官网注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云时国内专业CDN服务商，插件支持比较多，图片上传无限制。 搭建图床&emsp;&emsp;注册实名认证后，前往主页，进入对象存储，完成下面步骤 新建存储空间 上传文件 复制外链 &emsp;&emsp;得到的外链粘贴到浏览器的地址栏，可以直接获取到图片 &emsp;&emsp;这样就可以在md文章上插入图片了 1![](图片外链) 绑定域名&emsp;&emsp;新建存储空间七牛云提供一个测试域名，测试域名自创建起 30 个自然日后系统会自动回收，所以需要绑定一个自己的域名。长久之计。 &emsp;&emsp;推荐绑定二级域名，配置域名解析CNAME，按指示走。博主配置的二级域名image.XXX.com 极简图床&emsp;&emsp;七牛云上传文件，一个一个的上传有点麻烦，在这里推荐使用极简图床]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ajax跨域请求问题]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%A7%A3%E5%86%B3ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[什么是跨域问题&emsp;&emsp;跨域问题来源于JavaScript的同源策略（same-origin policy），即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源，同源策略用于保证用户信息安全，防止恶意的网站窃取数据。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等 。&emsp;&emsp;下面举几个例子： 12345http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域） 注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域，主机名不同。 解决ajax跨域问题的三种方法方法一：XHR2&emsp;&emsp;此种方法是HTML5的新功能，对post请求和get请求都有用，博主就是使用此种方法解决了跨域问题，在服务器端添加： 1234// 允许所有来源访问response.addHeader("Access-Control-Allow-Origin", "*");// 允许访问的方式addHeader("Access-Control-Allow-Method:POST,GET"); 方法二：JSONP注意：此种方法只对get请求有用 html前端代码： 123456789101112131415161718&lt;script type="text/javascript"&gt;$(function()&#123;$.ajax( &#123; type:'get', url : 'http://www.youxiaju.com/validate.php?loginuser=lee&amp;loginpass=123456', dataType : 'jsonp', jsonp:"jsoncallback", success : function(data) &#123; alert("用户名："+ data.user +" 密码："+ data.pass); &#125;, error : function() &#123; alert('fail'); &#125; &#125;);&#125;)&lt;/script&gt; 服务端代码： 123456789&lt;?phpheader('Content-Type:text/html;Charset=utf-8');$arr = array( "user" =&gt; $_GET['loginuser'], "pass" =&gt; $_GET['loginpass'], "name" =&gt; 'response' );echo $_GET['jsoncallback'] . "(".json_encode($arr).")"; 方法三：代理&emsp;&emsp;通过A后台(ASP、PHP、JAVA、ASP.NET)获取B其他域名下的数据，然后再把A获得数据返回到前端，这样因为在A和前端同一个域名下，所以就不会出现跨域的问题。 总结&emsp;&emsp;代理实现最麻烦，但使用最广泛，任何支持AJAX的浏览器都可以使用这种方式。&emsp;&emsp;JSONP相对简单，但只支持get请求调用。&emsp;&emsp;XHR2最简单，但只支持HTML5，如果是移动端开发，可以选择使用XHR2。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Tomcat中get请求和post请求中文乱码问题]]></title>
    <url>%2F2018%2F08%2F26%2F%E8%A7%A3%E5%86%B3get%E5%92%8Cpost%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[乱码原因对于国内的程序员来说，在做项目时避免不了的问题是中文乱码问题。Tomcat7及其以下版本对URI默认编码是ISO-8859-1，这种编码方式以单个字节作为一个字符，而汉字是以两个字节表示一个字符的。Tomcat8及其以上版本对URI默认编码是UTF-8，所以get请求和post请求解决中文乱码文题的方法有所不同。 get请求参数中文乱码解决办法如果是Tomcat8及其以上版本，无需解决get请求中文乱码问题 Tomcat7及其以下版本解决get请求中文乱码有两种方法 方法一 修改tomcat默认的编码方式为”UTF-8”在tomcat根目录下的conf/server.xml里把 &lt;Connector connectionTimeout=&quot;50000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 修改为 &lt;Connector connectionTimeout=&quot;50000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 注意：使用这种方式带来的问题是在你本机上这么做没有问题，你无论怎么去修改你tomcat上的配置都没问题，但是测试环境和生产环境的服务器不是轻易说改就能改的，特别是有些公司的服务器是租赁的，那么在我们不知道测试环境和生产环境服务器配置的时候就要使用下面的方法来解决get请求的中文乱码问题。 方法二因为get请求的参数在请求行上,Tomcat7及其以下版本对URI默认编码是ISO-8859-1。所以只能分别对请求行的汉字进行编码和解码。其实解决get请求中文乱码问题最好的方式是避免使用中文。 // name为请求行中的请求参数 String name = request.getParameter(&quot;name&quot;); // 先解码后编码 name = new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); post请求参数中文乱码解决办法对于post请求，参数在请求体中 如果是在servlet中，在获取参数前添加上下面这条语句即可 request.setCharacterEncoding(&quot;UTF-8&quot;); 如果使用spring进行开发，在web.xml中添加解决乱码过滤器 123456789101112131415&lt;filter&gt; &lt;description&gt;字符集过滤器&lt;/description&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;description&gt;字符集编码&lt;/description&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; // 对所有资源进行过滤，解决post请求中文乱码 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器解决get和post请求参数中文乱码使用servlet开发，如果使用上面的方法,每个servlet中都要进行设置编码，如果是post请求还好，但是如果是get请求,每个请求参数都要要手动进行转码，相当麻烦。 平常在servlet中接受请求的数据时可以使用request.getParameter(name)或者request.getParameterValues(name)进行获取，但这些方法如果不进行编码设置时，得到的数据都是乱码，这是因为浏览器传过来的数据的编码格式是iso-8859-1,而我们的开发平台一般都是使用的是utf-8，所以就会出现乱码现象。 这时也就是说request.getParameter(name)这些方法满足不了我们当前的需求，此时我们可以利用装饰者设计模式对这些方法进行增强。 而为了方便程序员对HttpServletRequest进行包装，javaEE中就已经提供好了一个基类HttpServletRequestWrapper这个类中已经实现其他需要实现的接口，我们只需要编写一个自己的类例如MyRequest继承它，需要增强哪个方法，就对哪个方法进行重写就行,没有重写的方法原来是如何执行的现在还会如何执行。 解决方法：使用过滤器对所有请求进行过滤，对请求中的request对象使用装饰者模式进行增强。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyRequest extends HttpServletRequestWrapper&#123; HttpServletRequest request=null; public MyRequest(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public String getParameter(String name) &#123; String method = request.getMethod(); String value=null; try &#123; request.setCharacterEncoding("utf-8"); value = request.getParameter(name); if("get".equalsIgnoreCase(method))&#123; value = new String(value.getBytes("iso-8859-1"),"utf-8"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return value; &#125; @Override public String[] getParameterValues(String name) &#123; String method = request.getMethod(); String[] values=null; try &#123; request.setCharacterEncoding("utf-8"); values = request.getParameterValues(name); if("get".equalsIgnoreCase(method))&#123; int i=0; for (String str : values) &#123; values[i++] = new String(str.getBytes("iso-8859-1"),"utf-8"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return values; &#125; &#125; 注意：过滤器中的代码实现，需要注意的是，在过滤器中放行传入的request对象，是我们经过增强后的MyRequest对象。 123456789public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; MyRequest myRrequest = new MyRequest(request); chain.doFilter(myRrequest, response); &#125; 使用过滤器后，这样在用servlet接受浏览器传过来的数据时，就不用考虑乱码的问题，过滤器已经帮我们解决了。 总结以上得知，尽量使用Tomcat8及其以上Tomcat服务器进行开发学习，这样就不用担心get请求参数中文乱码问题，post请求只要写一句request.setCharacterEncoding(&quot;utf-8&quot;);就够了，使用spring框架后也只需要在配置文件中加一个过滤器。 参考文章地址： 详解get请求和post请求参数中文乱码的解决办法 过滤器解决get和post方式提交的中文乱码]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的基本语法]]></title>
    <url>%2F2018%2F08%2F12%2Ffirst-blog-post%2F</url>
    <content type="text"><![CDATA[前言这还是我刚接触hexo，很多都不懂，这是我的一次练习文章，掌握基本的markdown语法 配置文件命名规则和路由地址Hexo 默认以标题作为文件名称，可以通过 Hexo 的配置文件 _config.yml 中的 new_post_name 参数来改变默认的文件名称，例如： 1new_post_name: :year-:month-:day-:title.md 当创建博客时，就会以这种格式生成Markdown文件，如这篇博客的文件名就生成 2018-08-12-first-blog-post.md这种形式。其中相关变量说明如下表： 变量 说明 :title 标题（小写， 空格将会被替换为短杠） :year 创建的年份，如：2018 :month 创建的月份（有前导零），如：01 :i_month 创建的月份（无前导零），如：1 :day 创建的日期（有前导零），如：09 :i_day 创建的月份（无前导零），如：9 配置浏览器地址栏中的URL。同样在 Hexo 的配置文件_config.yml中, 配置 permalink属性 ，例如： 1permalink: /blog/:year/:month/:day/:title/ 当在地址栏访问时，就会如下方式呈现出来： 1https://xu-yh.github.io/2018/08/12/first-blog-post/ 创建博客文章在命令行中用如下命令创建一篇新的文章 1$ hexo new [layout] &lt;title&gt; 布局（layout） 存储路径 说明 post source/_posts 默认，可以直接发布 page source 在source下新建一个文件夹 draft source/_drafts 新建文件将保持到_drafts中 可以用 publish命令将草稿移动到 source/_posts文件夹下 1$ hexo publish [layout] &lt;title&gt; 编写内容打开source/_posts 文件夹下刚创建的 Markdown 文件，如：/source/_posts/first-blog-post你会发现有如下内容： 12345---title: first-blog-postdate: 2018-08-12 21:06:50tags: --- 注意，这里的title是可以随便改的，当然了 date也是可以改，不过没有改的必要；这里要说一下 tags这个属性，如果需要配置多个有两种方式： 1tags: [tag1, tag2, tag3] 或者： 1234tags: - tag1 - tag2 - tag3 标题标题分为五级，依次字号变小 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表无序列表写法： 123* 无序列表项1+ 无序列表项2- 无序列表项3 效果： 无序列表项1 无序列表项2 无序列表项3 有序列表写法： 1231.有序列表项12.有序列表项23.有序列表项3 效果：1.有序列表项12.有序列表项23.有序列表项3 斜体与粗体写法： 1234*这是斜体* 或 _这也是斜体_ **这是粗体*****这是加粗斜体***~~这是删除线~~ 效果： 这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 超链接写法： 12345行内形式：[我的博客](https://xu-yh.github.io/)参考形式：[我的博客][1]，[我的github][2][1]:https://xu-yh.github.io/[2]:https://github.com/XU-YH自动链接：我的博客地址&lt;https://xu-yh.github.io/&gt; 效果： 行内形式：我的博客参考形式：[我的博客][1]，[我的github][2][1]:https://xu-yh.github.io/[2]:https://github.com/XU-YH自动链接：我的博客地址https://xu-yh.github.io/ 表格写法： 12345| 表头1| 表头2| 表头3| 表头4| -| :- | :-: | -: || 默认左对齐| 左对齐| 居中对其| 右对齐|| 默认左对齐| 左对齐| 居中对其| 右对齐|| 默认左对齐| 左对齐| 居中对其| 右对齐| 效果： 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 插入图片写法： 12![](/images/insert_image.jpg)这里的地址可以使本地地址，也可以是图片网址 效果： 引用写法： 1&gt; 这是引用 效果： 这是引用 分割线写法： 123---***三个-或* 效果： 需要注意的是：标记与内容之间必须空一行隔开 结语 这篇文章写了有两个多小时了，结果是值得的，从网上摘抄过来的知识，自己整理出来，收获很多，掌握了markdown的基本语法，下次写文章会轻松很多吧！ 第一次写文章有什么错误和意见希望在下方留言告诉我，大佬教教我。 参考文章地址： 如何写一篇hexo博客 用Hexo写出第一篇博客]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
