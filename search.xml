<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法之交换排序]]></title>
    <url>%2F2019%2F09%2F28%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;算法中的交换排序，顾名思义，就是发现两个待排序的记录的次序与我们想要的次序相反时，交换这两个记录的位置，直到没有反序的记录为止。交换排序可分为冒泡排序和快速排序，下面是详情。 冒泡排序 &emsp;&emsp;冒泡排序是交换排序中最简单的一种，以数组的升序为例，指针从数组的第一个位置开始，与下个位置的元素进行比较，若当前位置的元素大于下个位置的元素，两个元素进行交换，否则不交换，同时指针指向下一个位置，以此循环，直至最大的元素出现数组的最后一个位置，，，。冒泡排序的时间复杂度为O(n2)。 1234567891011121314151617/** * 冒泡排序 * * @param arr 数组 */public static void bubbleSort(int[] arr) &#123; int length = arr.length; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 快速排序 &emsp;&emsp;快速排序是排序算法中最快的，平均时间复杂度为O(nlog2 n)，有点像二分法，采取“分而治之”的方式，利用从数据集中选取的基准值将数据集分成两组子数据集，通过两个子数据集中的元素比较，得到基准值在数据集中应该的位置。 &emsp;&emsp;基准值的选取策略决定了快速排序的性能，如果没吃选取的基准值为最大或是最小值时，出现两个子数据集中的一个没有元素，快速排序退化为冒泡排序，这里采用的是三数中值分割法,指取第一个元素，中间的元素和最后一个元素的中值作为基准值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 快速排序 * 快速排序是交换排序中的一种，是排序算法中速度最快的，平均时间复杂度为O（nlogn)。 * * @param arr 数组 * @param left 数组左指针 * @param right 数组右指针 */public static void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int pivot = getPivot(arr, left, right); // 可以简单的选择第一个或是最后一个元素作为基准值 // int pivot = arr[right]; int i = left; int j = right; while (true) &#123; while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123; i++; &#125; while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123; j--; &#125; if (i &lt; j) &#123; swap(arr, i, j); &#125; else &#123; break; &#125; &#125; swap(arr, i, right); quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;/** * 三数中值分割法，选取基准值（枢纽元），除获取枢纽元外，还将枢纽元放到数组的最后，为的是基准值和数组其他值隔离开。 * 使用三数中值分割法可使性能提高5% * * @param arr * @param left * @param right * @return */public static int getPivot(int[] arr, int left, int right) &#123; int center = (left + right) / 2; if (arr[left] &gt; arr[center]) &#123; swap(arr, left, center); &#125; if (arr[left] &gt; arr[right]) &#123; swap(arr, left, right); &#125; if (arr[center] &gt; arr[right]) &#123; swap(arr, center, right); &#125; swap(arr, center, right); return arr[right];&#125;/** * 交换数组中两个元素的值 * * @param arr * @param index1 * @param index2 */public static void swap(int[] arr, int index1, int index2) &#123; int temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp;&#125; 总结 &emsp;&emsp;虽然快速排序比冒泡排序要快，但是快速排序基准值没选好最坏的情况下，时间复杂度也是O(n2)，快速排序逻辑上也更为复杂。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring中的父子容器]]></title>
    <url>%2F2018%2F10%2F02%2FSpring%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在项目中使用Spring和SpringMVC框架时，三层架构中的controller层可能出现注解没有用，或者SpringMVC前端控制器无法跳转以及事务的配置失效的问题，这些问题就可能是Spring中的父子容器导致的。 概念理解 &emsp;&emsp;首先在Spring中，容器可以有多个，容器之间可能存在上下层关系，也就是父子关系。目前最常见的就是在一个项目中引入Spring和SpringMVC这两个框架，这两个框架就是两个容器。 &emsp;&emsp;Spring容器 – 父容器&emsp;&emsp;SpringMVC容器 – 子容器 父子容器的关系： 子容器能够访问父容器的资源（bean）&emsp;&emsp;示例：Controller可以注入Service 父容器不能访问子容器的资源（bean） 具体分析 &emsp;&emsp;使用注解开发，在Spring框架的配置文件applicationContext.xml中添加下面这句话扫描所有的包，Spring容器加载时会将被@Component注解的类自动注册到容器中，@Controller，@Service，@Respository这三个注解继承于@Component，并且会扫描类中的@Required、@Autowired、@Resource等注解。 12&lt;!-- 配置扫描 --&gt;&lt;context:component-scan base-package="com.xuyinhui" /&gt; &emsp;&emsp;在SpringMVC框架的配置文件springmvc.xml中的必写配置，它声明了@RequestMapping、@RequestBody、@ResponseBody等一些默认配置。 12&lt;!-- 注册驱动 --&gt;&lt;mvc:annotation-driven /&gt; &emsp;&emsp;当SpringMVC初始化时，会自动寻找SpringMVC容器中的所有使用了@Controller注解的bean，来确定是否需要一个handler。如果按照上面的配置，SpringMVC容器中是没有带有@Controller注解的bean的，全都注册在Spring父容器中，所以SpringMVC找不到处理器，因此就会出现前端控制器失效，无法进行跳转的问题。 &emsp;&emsp;注意：使用@Value获取配置文件的值时 123// 假设从image.properties配置文件中获取图片地址@Value("$&#123;IMAGE_URL&#125;")private String IMAGE_URL; 在Spring容器初始化（所有的bean）之后，再从当前的所在容器中获取值，然后注入。 总结 &emsp;&emsp;理解Spring和SpringMVC的父子容器关系后，在这里官方也建议我们把不同类型的Bean分配到不同的容器中进行管理。这样就可以避免Bean找不到或者SpringMVC不能跳转以及事务的配置失效的问题了。如以下配置： &emsp;&emsp;在SpringMVC框架配置文件springmvc.xml中 12&lt;!-- 配置controller扫描包 --&gt;&lt;context:component-scan base-package="com.xuyinhui.controller" /&gt; &emsp;&emsp;在Spring框架配置文件applicationContext.xml中 12345678&lt;!-- 配置Mapper扫描，动态代理 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置Mapper扫描包 --&gt; &lt;property name="basePackage" value="com.xuyinhui.dao" /&gt;&lt;/bean&gt;&lt;!-- 配置service扫描 --&gt;&lt;context:component-scan base-package="com.xuyinhui.service" /&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的使用]]></title>
    <url>%2F2018%2F09%2F27%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Git是分布式版本控制系统，CVS及SVN都是集中式的版本控制系统。&emsp;&emsp;集中式版本控制系统，版本库（代码）是集中存放在中央服务器的，工作时，用的都是自己的电脑，所以每个人要先从中央服务器取得最新的版本，然后开始工作，工作结束后，再把自己的代码推送给中央服务器。&emsp;&emsp;分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。&emsp;&emsp;两个有什么不同呢？&emsp;&emsp;分布式版本控制系统（Git）相较于集中式版本控制系统SVN，Git不需要联网，速度快，安全性高，一旦SVN的中央服务器挂了，所有人都收到了影响，而且Git拥有极其强大的分支管理 常用到的git命令&emsp;&emsp;以下是博主常用到的一些git命令 12345678910111213 // 通过git init命令把这个目录变成Git可以管理的仓库$ git init // 显示仓库的当前状态 // 如果git status告诉你有文件被修改过，用git diff命令可以查看修改内容。$ git status // 与远程仓库相关联 $ git remote add origin git@github.com:XU-YH/(项目名).git$ git pull --rebase origin master // * 代表所有文件$ git add * $ git commit -m &quot;add distributed&quot; $ git pull $ git push origin branch-name git命令版本回退 123456789101112 //显示从最近到最远的提交日志$ git log //看到的一大串类似3628164...882e1e0的是commit_id（版本号）（十六进制） //简化信息$ git log --pretty=oneline //回退到上一个版本$ git reset --hard HEAD^ //指定回到某个版本，根据版本号找，版本号没必要写全，前几位就可以了 //HEAD指向哪个版本号，你就把当前版本定位在哪$ git reset --hard commit_id //查看命令历史，以便确定要回到哪个版本$ git reflog 工作区和暂存区 管理修改：Git管理的是修改 撤销修改 &emsp;&emsp;文件已修改，未add到暂存区:12// 让这个文件回到最近一次git commit或git add时的状态git checkout -- file &emsp;&emsp;文件已修改，并add到暂存区未commit： 12git reset HEAD file git checkout -- file &emsp;&emsp;文件已修改，并add到暂存区且commit：版本回退吧 删除文件 1234567 //rm命令删除文件$ rm test.txt //删除版本库里的文件$ git rm test.txt //删错了文件，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本$ git checkout -- test.txt //git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 创建与合并分支 &emsp;&emsp;在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。&emsp;&emsp;截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 1234567查看分支：git branch （当前分支前面会标一个*号）创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 解决冲突 master分支和feature1分支各自都分别有新的提交，这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突 1$ git merge feature1 存在冲突，必须手动解决冲突后再提交 分支管理策略 &emsp;&emsp;通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 1234567$ git checkout -b dev //修改readme.txt文件$ git add readme.txt$ git commit -m &quot;add merge&quot;$ git checkout master //合并dev分支，请注意--no-ff参数，表示禁用Fast forward：$ git merge --no-ff -m &quot;merge with no-ff&quot; dev Bug分支 &emsp;&emsp;软件开发中，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。&emsp;&emsp;当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 1234567891011 （新文件修改后，要先add到stage中，然后再stash)$ git stash$ git checkout master 现在就可以去修改Bug了 改好了$ git checkout dev$ git stash list（查看） Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了$ git stash pop Feature分支 &emsp;&emsp;开发一个新feature(实验性质的代码)，最好新建一个分支；&emsp;&emsp;如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除，如果分支中没有添加新的数据（空的文件）是可以通过git branch -d &lt;name&gt;删除 多人协作 &emsp;&emsp;A：首先，可以试图用git push origin branch-name推送自己的修改；&emsp;&emsp;B：如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；&emsp;&emsp;C：如果合并有冲突，则解决冲突，并在本地提交；&emsp;&emsp;D：没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！&emsp;&emsp;E：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令$ git branch --set-upstream-to=origin/branch-name。 &emsp;&emsp;查看远程库信息，使用git remote -v；&emsp;&emsp;本地新建的分支如果不推送到远程，对其他人就是不可见的；&emsp;&emsp;你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：$ git checkout -b branch-name origin/branch-name 结语&emsp;&emsp;这是2017年初次学习git时参照廖雪峰老师的博客整理出的学习笔记，学习git命令，常用的命令也不多，博主现在使用github提供的pc客户端使用的多，命令行不经常敲就会忘 -_-，GitHub for Windows客户端也非常的好用，也推荐大家使用。 参考文章地址： 廖雪峰Git教程 git本地项目代码上传至码云远程仓库总结 git无法pull仓库refusing to merge unrelated histories]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八达岭长城游记]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%85%AB%E8%BE%BE%E5%B2%AD%E9%95%BF%E5%9F%8E%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[长城 前言 &emsp;&emsp;转眼间，已经来北京两个月了，一直想去各大景点转转，碍于天气原因，北京真的热，晒得慌。最终决定在这个周六自己宿舍加上旁边宿舍的小伙伴们一起爬长城，嘟嘟嘟。 登城前 &emsp;&emsp;原计划八点出发，然而计划就是被用来打破的，，，八点十五出发，十二个人坐公交车。换乘第二班公交车（877路）遇到第一个坑，在站台等车，许多小车围了上来，载客，各种劝说。最后公交车来了，这个坑没往下跳。&emsp;&emsp;在公交车上已经能看到长城了，依山势而建，内心还是很兴奋的，然而我晕车，要吐，表示很难受。到达八达岭站后，在小姐姐的解说（糊弄？）下买了门票和往返的滑车票，一共140，这时候已经入坑了。然后开始登城，嘟嘟嘟~ 登城 开始登城 &emsp;&emsp;进入长城前的黑熊，都懒洋洋的，圈养的动物。 胖乎乎的熊 &emsp;&emsp;坐滑车，呃呃呃，这不是我想象中的滑车 滑车 登城中 &emsp;&emsp;最大的感受是好陡啊，有的台阶高低不一样，极易踩空，而且很多是没有台阶的，几百年前的人，士兵，是怎么在这上面保卫国家的呢，不易啊。 爬啊爬啊 爬啊爬啊 &emsp;&emsp;长城上的蜘蛛，在这山上，它吃什么呢？它一个蛛孤单吗？ 蜘蛛 &emsp;&emsp;长城上不热，就是很晒，相当晒，感谢这多云朵带来几分钟的阴凉。 云朵 &emsp;&emsp;北十楼是跑着到的，当时快喘不上气，空气又非常干燥，坐在烽火台里喘会气。坐在那里你都能感觉到腿在发抖，&gt;-&lt; 北十楼 &emsp;&emsp;大家停下来休息，吃零食，吃午饭，爬累了，爬饿了。 小伙伴 &emsp;&emsp;最后一楼，北十二。可以回去了。- \/ - 北十二楼 登城后 &emsp;&emsp;从北十一楼下了长城，大家纷纷表示腿疼。出出口就可以看到卖纪念品的，进去逛了逛。 纪念礼品店 &emsp;&emsp;第二个坑，被所谓的志愿指导小姐姐忽悠卖了门票加滑车往返票。北四楼坐滑车上去，北十一就有下去的出口，谁会为了渣渣滑车往回走呢？直接下去比往回走近多了，退滑车票只退20。而且，北一楼售票处是单买门票的，从北四楼入口走去北一楼入口只要二十分钟，开始骗我们在山的另一边，要走两个小时，呜呜呜。 售票处 &emsp;&emsp;饿了，小镇上的肉夹馍，有点干。 肉夹馍 &emsp;&emsp;本人了。 me 所感 &emsp;&emsp;有些地方是值得去看一遍的。&emsp;&emsp;站在长城上除了看到长城，还能看到翻山越岭的高压电线和高速公路火车，这是现代社会的奇迹，然而长城的历史可以追溯到两千多年前的秦始皇，时代不断变迁，如今的八达岭长城是几百年前的明清长城遗址经过修缮后的，但是这只是万里长城中的一段，可想当年，真正的万里长城，连绵起伏，气势磅礴，佩服古人，靠人力在险峻的山峰上修建长城，在长城上站岗巡视保卫国家，这是一个名族的骄傲。&emsp;&emsp;旅游规划好，多看攻略，别再被坑了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>北京</tag>
        <tag>长城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用七牛云存储搭建图床]]></title>
    <url>%2F2018%2F09%2F07%2F%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[为什么需要图床&emsp;&emsp;使用markdown写文章，注重的是文章的文字和排版，但是有时难免会用到图片，如果是别的站点的图片，可能源站点设置图片的防盗链，而且源站点删除了图片，自己就遭殃了，如果是自己的图片，上传到自己购买的服务器上，还不如第三方图床，速度和功能上第三方都进行过升级优化。 七牛云&emsp;&emsp;七牛云官方地址：https://portal.qiniu.com&emsp;&emsp;官网注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云时国内专业CDN服务商，插件支持比较多，图片上传无限制。 搭建图床&emsp;&emsp;注册实名认证后，前往主页，进入对象存储，完成下面步骤 新建存储空间 上传文件 复制外链 &emsp;&emsp;得到的外链粘贴到浏览器的地址栏，可以直接获取到图片 &emsp;&emsp;这样就可以在md文章上插入图片了 1![](图片外链) 绑定域名&emsp;&emsp;新建存储空间七牛云提供一个测试域名，测试域名自创建起 30 个自然日后系统会自动回收，所以需要绑定一个自己的域名。长久之计。 &emsp;&emsp;推荐绑定二级域名，配置域名解析CNAME，按指示走。博主配置的二级域名image.XXX.com 极简图床&emsp;&emsp;七牛云上传文件，一个一个的上传有点麻烦，在这里推荐使用极简图床]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ajax跨域请求问题]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%A7%A3%E5%86%B3ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[什么是跨域问题&emsp;&emsp;跨域问题来源于JavaScript的同源策略（same-origin policy），即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源，同源策略用于保证用户信息安全，防止恶意的网站窃取数据。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等 。&emsp;&emsp;下面举几个例子： 12345http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域） 注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域，主机名不同。 解决ajax跨域问题的三种方法方法一：XHR2&emsp;&emsp;此种方法是HTML5的新功能，对post请求和get请求都有用，博主就是使用此种方法解决了跨域问题，在服务器端添加： 1234// 允许所有来源访问response.addHeader("Access-Control-Allow-Origin", "*");// 允许访问的方式addHeader("Access-Control-Allow-Method:POST,GET"); 方法二：JSONP注意：此种方法只对get请求有用 &emsp;&emsp;Jsonp的原理：1.jsonp通过script标签的src可以跨域请求的特性，加载资源2.将加载的资源（通过一个方法名将数据进行包裹）当做是js脚本解析3.定义一个回调函数，获取传入的数据 html前端代码： 123456789101112131415161718&lt;script type="text/javascript"&gt;$(function()&#123;$.ajax( &#123; type:'get', url : 'http://www.youxiaju.com/validate.php?loginuser=lee&amp;loginpass=123456', dataType : 'jsonp', jsonp:"jsoncallback", success : function(data) &#123; alert("用户名："+ data.user +" 密码："+ data.pass); &#125;, error : function() &#123; alert('fail'); &#125; &#125;);&#125;)&lt;/script&gt; 服务端代码： 123456789&lt;?phpheader('Content-Type:text/html;Charset=utf-8');$arr = array( "user" =&gt; $_GET['loginuser'], "pass" =&gt; $_GET['loginpass'], "name" =&gt; 'response' );echo $_GET['jsoncallback'] . "(".json_encode($arr).")"; 方法三：代理&emsp;&emsp;通过A后台(ASP、PHP、JAVA、ASP.NET)获取B其他域名下的数据，然后再把A获得数据返回到前端，这样因为在A和前端同一个域名下，所以就不会出现跨域的问题。 总结&emsp;&emsp;代理实现最麻烦，但使用最广泛，任何支持AJAX的浏览器都可以使用这种方式。&emsp;&emsp;JSONP相对简单，但只支持get请求调用。&emsp;&emsp;XHR2最简单，但只支持HTML5，如果是移动端开发，可以选择使用XHR2。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Tomcat中get请求和post请求中文乱码问题]]></title>
    <url>%2F2018%2F08%2F26%2F%E8%A7%A3%E5%86%B3get%E5%92%8Cpost%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[乱码原因对于国内的程序员来说，在做项目时避免不了的问题是中文乱码问题。Tomcat7及其以下版本对URI默认编码是ISO-8859-1，这种编码方式以单个字节作为一个字符，而汉字是以两个字节表示一个字符的。Tomcat8及其以上版本对URI默认编码是UTF-8，所以get请求和post请求解决中文乱码文题的方法有所不同。 get请求参数中文乱码解决办法如果是Tomcat8及其以上版本，无需解决get请求中文乱码问题 Tomcat7及其以下版本解决get请求中文乱码有两种方法 方法一 修改tomcat默认的编码方式为”UTF-8”在tomcat根目录下的conf/server.xml里把 &lt;Connector connectionTimeout=&quot;50000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 修改为 &lt;Connector connectionTimeout=&quot;50000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 注意：使用这种方式带来的问题是在你本机上这么做没有问题，你无论怎么去修改你tomcat上的配置都没问题，但是测试环境和生产环境的服务器不是轻易说改就能改的，特别是有些公司的服务器是租赁的，那么在我们不知道测试环境和生产环境服务器配置的时候就要使用下面的方法来解决get请求的中文乱码问题。 方法二因为get请求的参数在请求行上,Tomcat7及其以下版本对URI默认编码是ISO-8859-1。所以只能分别对请求行的汉字进行编码和解码。其实解决get请求中文乱码问题最好的方式是避免使用中文。 // name为请求行中的请求参数 String name = request.getParameter(&quot;name&quot;); // 先解码后编码 name = new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); post请求参数中文乱码解决办法对于post请求，参数在请求体中 如果是在servlet中，在获取参数前添加上下面这条语句即可 request.setCharacterEncoding(&quot;UTF-8&quot;); 如果使用spring进行开发，在web.xml中添加解决乱码过滤器 123456789101112131415&lt;filter&gt; &lt;description&gt;字符集过滤器&lt;/description&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;description&gt;字符集编码&lt;/description&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; // 对所有资源进行过滤，解决post请求中文乱码 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器解决get和post请求参数中文乱码使用servlet开发，如果使用上面的方法,每个servlet中都要进行设置编码，如果是post请求还好，但是如果是get请求,每个请求参数都要要手动进行转码，相当麻烦。 平常在servlet中接受请求的数据时可以使用request.getParameter(name)或者request.getParameterValues(name)进行获取，但这些方法如果不进行编码设置时，得到的数据都是乱码，这是因为浏览器传过来的数据的编码格式是iso-8859-1,而我们的开发平台一般都是使用的是utf-8，所以就会出现乱码现象。 这时也就是说request.getParameter(name)这些方法满足不了我们当前的需求，此时我们可以利用装饰者设计模式对这些方法进行增强。 而为了方便程序员对HttpServletRequest进行包装，javaEE中就已经提供好了一个基类HttpServletRequestWrapper这个类中已经实现其他需要实现的接口，我们只需要编写一个自己的类例如MyRequest继承它，需要增强哪个方法，就对哪个方法进行重写就行,没有重写的方法原来是如何执行的现在还会如何执行。 解决方法：使用过滤器对所有请求进行过滤，对请求中的request对象使用装饰者模式进行增强。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyRequest extends HttpServletRequestWrapper&#123; HttpServletRequest request=null; public MyRequest(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public String getParameter(String name) &#123; String method = request.getMethod(); String value=null; try &#123; request.setCharacterEncoding("utf-8"); value = request.getParameter(name); if("get".equalsIgnoreCase(method))&#123; value = new String(value.getBytes("iso-8859-1"),"utf-8"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return value; &#125; @Override public String[] getParameterValues(String name) &#123; String method = request.getMethod(); String[] values=null; try &#123; request.setCharacterEncoding("utf-8"); values = request.getParameterValues(name); if("get".equalsIgnoreCase(method))&#123; int i=0; for (String str : values) &#123; values[i++] = new String(str.getBytes("iso-8859-1"),"utf-8"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return values; &#125; &#125; 注意：过滤器中的代码实现，需要注意的是，在过滤器中放行传入的request对象，是我们经过增强后的MyRequest对象。 123456789public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; MyRequest myRrequest = new MyRequest(request); chain.doFilter(myRrequest, response); &#125; 使用过滤器后，这样在用servlet接受浏览器传过来的数据时，就不用考虑乱码的问题，过滤器已经帮我们解决了。 总结以上得知，尽量使用Tomcat8及其以上Tomcat服务器进行开发学习，这样就不用担心get请求参数中文乱码问题，post请求只要写一句request.setCharacterEncoding(&quot;utf-8&quot;);就够了，使用spring框架后也只需要在配置文件中加一个过滤器。 参考文章地址： 详解get请求和post请求参数中文乱码的解决办法 过滤器解决get和post方式提交的中文乱码]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的基本语法]]></title>
    <url>%2F2018%2F08%2F12%2Ffirst-blog-post%2F</url>
    <content type="text"><![CDATA[前言这还是我刚接触hexo，很多都不懂，这是我的一次练习文章，掌握基本的markdown语法 配置文件命名规则和路由地址Hexo 默认以标题作为文件名称，可以通过 Hexo 的配置文件 _config.yml 中的 new_post_name 参数来改变默认的文件名称，例如： 1new_post_name: :year-:month-:day-:title.md 当创建博客时，就会以这种格式生成Markdown文件，如这篇博客的文件名就生成 2018-08-12-first-blog-post.md这种形式。其中相关变量说明如下表： 变量 说明 :title 标题（小写， 空格将会被替换为短杠） :year 创建的年份，如：2018 :month 创建的月份（有前导零），如：01 :i_month 创建的月份（无前导零），如：1 :day 创建的日期（有前导零），如：09 :i_day 创建的月份（无前导零），如：9 配置浏览器地址栏中的URL。同样在 Hexo 的配置文件_config.yml中, 配置 permalink属性 ，例如： 1permalink: /blog/:year/:month/:day/:title/ 当在地址栏访问时，就会如下方式呈现出来： 1https://xu-yh.github.io/2018/08/12/first-blog-post/ 创建博客文章在命令行中用如下命令创建一篇新的文章 1$ hexo new [layout] &lt;title&gt; 布局（layout） 存储路径 说明 post source/_posts 默认，可以直接发布 page source 在source下新建一个文件夹 draft source/_drafts 新建文件将保持到_drafts中 可以用 publish命令将草稿移动到 source/_posts文件夹下 1$ hexo publish [layout] &lt;title&gt; 编写内容打开source/_posts 文件夹下刚创建的 Markdown 文件，如：/source/_posts/first-blog-post你会发现有如下内容： 12345---title: first-blog-postdate: 2018-08-12 21:06:50tags: --- 注意，这里的title是可以随便改的，当然了 date也是可以改，不过没有改的必要；这里要说一下 tags这个属性，如果需要配置多个有两种方式： 1tags: [tag1, tag2, tag3] 或者： 1234tags: - tag1 - tag2 - tag3 标题标题分为五级，依次字号变小 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表无序列表写法： 123* 无序列表项1+ 无序列表项2- 无序列表项3 效果： 无序列表项1 无序列表项2 无序列表项3 有序列表写法： 1231.有序列表项12.有序列表项23.有序列表项3 效果：1.有序列表项12.有序列表项23.有序列表项3 斜体与粗体写法： 1234*这是斜体* 或 _这也是斜体_ **这是粗体*****这是加粗斜体***~~这是删除线~~ 效果： 这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 超链接写法： 12345行内形式：[我的博客](https://xu-yh.github.io/)参考形式：[我的博客][1]，[我的github][2][1]:https://xu-yh.github.io/[2]:https://github.com/XU-YH自动链接：我的博客地址&lt;https://xu-yh.github.io/&gt; 效果： 行内形式：我的博客参考形式：[我的博客][1]，[我的github][2][1]:https://xu-yh.github.io/[2]:https://github.com/XU-YH自动链接：我的博客地址https://xu-yh.github.io/ 表格写法： 12345| 表头1| 表头2| 表头3| 表头4| -| :- | :-: | -: || 默认左对齐| 左对齐| 居中对其| 右对齐|| 默认左对齐| 左对齐| 居中对其| 右对齐|| 默认左对齐| 左对齐| 居中对其| 右对齐| 效果： 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 插入图片写法： 12![](/images/insert_image.jpg)这里的地址可以使本地地址，也可以是图片网址 效果： 引用写法： 1&gt; 这是引用 效果： 这是引用 分割线写法： 123---***三个-或* 效果： 需要注意的是：标记与内容之间必须空一行隔开 结语 这篇文章写了有两个多小时了，结果是值得的，从网上摘抄过来的知识，自己整理出来，收获很多，掌握了markdown的基本语法，下次写文章会轻松很多吧！ 第一次写文章有什么错误和意见希望在下方留言告诉我，大佬教教我。 参考文章地址： 如何写一篇hexo博客 用Hexo写出第一篇博客]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
