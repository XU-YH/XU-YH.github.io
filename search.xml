<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Tomcat中get请求和post请求中文乱码问题]]></title>
    <url>%2F2018%2F08%2F26%2F%E8%A7%A3%E5%86%B3get%E5%92%8Cpost%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[乱码原因对于国内的程序员来说，在做项目时避免不了的问题是中文乱码问题。Tomcat7及其以下版本对URI默认编码是ISO-8859-1，这种编码方式以单个字节作为一个字符，而汉字是以两个字节表示一个字符的。Tomcat8及其以上版本对URI默认编码是UTF-8，所以get请求和post请求解决中文乱码文题的方法有所不同。 get请求参数中文乱码解决办法如果是Tomcat8及其以上版本，无需解决get请求中文乱码问题 Tomcat7及其以下版本解决get请求中文乱码有两种方法 方法一 修改tomcat默认的编码方式为”UTF-8”在tomcat根目录下的conf/server.xml里把 &lt;Connector connectionTimeout=&quot;50000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 修改为 &lt;Connector connectionTimeout=&quot;50000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 注意：使用这种方式带来的问题是在你本机上这么做没有问题，你无论怎么去修改你tomcat上的配置都没问题，但是测试环境和生产环境的服务器不是轻易说改就能改的，特别是有些公司的服务器是租赁的，那么在我们不知道测试环境和生产环境服务器配置的时候就要使用下面的方法来解决get请求的中文乱码问题。 方法二因为get请求的参数在请求行上,Tomcat7及其以下版本对URI默认编码是ISO-8859-1。所以只能分别对请求行的汉字进行编码和解码。其实解决get请求中文乱码问题最好的方式是避免使用中文。 // name为请求行中的请求参数 String name = request.getParameter(&quot;name&quot;); // 先解码后编码 name = new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); post请求参数中文乱码解决办法对于post请求，参数在请求体中 如果是在servlet中，在获取参数前添加上下面这条语句即可 request.setCharacterEncoding(&quot;UTF-8&quot;); 如果使用spring进行开发，在spring的配置文件中添加解决乱码过滤器 123456789101112131415&lt;filter&gt; &lt;description&gt;字符集过滤器&lt;/description&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;description&gt;字符集编码&lt;/description&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; // 对所有资源进行过滤，解决post请求中文乱码 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器解决get和post请求参数中文乱码使用servlet开发，如果使用上面的方法,每个servlet中都要进行设置编码，如果是post请求还好，但是如果是get请求,每个请求参数都要要手动进行转码，相当麻烦。 平常在servlet中接受请求的数据时可以使用request.getParameter(name)或者request.getParameterValues(name)进行获取，但这些方法如果不进行编码设置时，得到的数据都是乱码，这是因为浏览器传过来的数据的编码格式是iso-8859-1,而我们的开发平台一般都是使用的是utf-8，所以就会出现乱码现象。 这时也就是说request.getParameter(name)这些方法满足不了我们当前的需求，此时我们可以利用装饰者设计模式对这些方法进行增强。 而为了方便程序员对HttpServletRequest进行包装，javaEE中就已经提供好了一个基类HttpServletRequestWrapper这个类中已经实现其他需要实现的接口，我们只需要编写一个自己的类例如MyRequest继承它，需要增强哪个方法，就对哪个方法进行重写就行,没有重写的方法原来是如何执行的现在还会如何执行。 解决方法：使用过滤器对所有请求进行过滤，对请求中的request对象使用装饰者模式进行增强。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyRequest extends HttpServletRequestWrapper&#123; HttpServletRequest request=null; public MyRequest(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public String getParameter(String name) &#123; String method = request.getMethod(); String value=null; try &#123; request.setCharacterEncoding("utf-8"); value = request.getParameter(name); if("get".equalsIgnoreCase(method))&#123; value = new String(value.getBytes("iso-8859-1"),"utf-8"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return value; &#125; @Override public String[] getParameterValues(String name) &#123; String method = request.getMethod(); String[] values=null; try &#123; request.setCharacterEncoding("utf-8"); values = request.getParameterValues(name); if("get".equalsIgnoreCase(method))&#123; int i=0; for (String str : values) &#123; values[i++] = new String(str.getBytes("iso-8859-1"),"utf-8"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return values; &#125; &#125; 注意：过滤器中的代码实现，需要注意的是，在过滤器中放行传入的request对象，是我们经过增强后的MyRequest对象。 123456789public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; MyRequest myRrequest = new MyRequest(request); chain.doFilter(myRrequest, response); &#125; 使用过滤器后，这样在用servlet接受浏览器传过来的数据时，就不用考虑乱码的问题，过滤器已经帮我们解决了。 总结以上得知，尽量使用Tomcat8及其以上Tomcat服务器进行开发学习，这样就不用担心get请求参数中文乱码问题，post请求只要写一句request.setCharacterEncoding(&quot;utf-8&quot;);就够了，使用spring框架后也只需要在配置文件中加一个过滤器。 参考文章地址： 详解get请求和post请求参数中文乱码的解决办法 过滤器解决get和post方式提交的中文乱码]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的基本语法]]></title>
    <url>%2F2018%2F08%2F12%2Ffirst-blog-post%2F</url>
    <content type="text"><![CDATA[前言这还是我刚接触hexo，很多都不懂，这是我的一次练习文章，掌握基本的markdown语法 配置文件命名规则和路由地址Hexo 默认以标题作为文件名称，可以通过 Hexo 的配置文件 _config.yml 中的 new_post_name 参数来改变默认的文件名称，例如： 1new_post_name: :year-:month-:day-:title.md 当创建博客时，就会以这种格式生成Markdown文件，如这篇博客的文件名就生成 2018-08-12-first-blog-post.md这种形式。其中相关变量说明如下表： 变量 说明 :title 标题（小写， 空格将会被替换为短杠） :year 创建的年份，如：2018 :month 创建的月份（有前导零），如：01 :i_month 创建的月份（无前导零），如：1 :day 创建的日期（有前导零），如：09 :i_day 创建的月份（无前导零），如：9 配置浏览器地址栏中的URL。同样在 Hexo 的配置文件_config.yml中, 配置 permalink属性 ，例如： 1permalink: /blog/:year/:month/:day/:title/ 当在地址栏访问时，就会如下方式呈现出来： 1https://xu-yh.github.io/2018/08/12/first-blog-post/ 创建博客文章在命令行中用如下命令创建一篇新的文章 1$ hexo new [layout] &lt;title&gt; 布局（layout） 存储路径 说明 post source/_posts 默认，可以直接发布 page source 在source下新建一个文件夹 draft source/_drafts 新建文件将保持到_drafts中 可以用 publish命令将草稿移动到 source/_posts文件夹下 1$ hexo publish [layout] &lt;title&gt; 编写内容打开source/_posts 文件夹下刚创建的 Markdown 文件，如：/source/_posts/first-blog-post你会发现有如下内容： 12345---title: first-blog-postdate: 2018-08-12 21:06:50tags: --- 注意，这里的title是可以随便改的，当然了 date也是可以改，不过没有改的必要；这里要说一下 tags这个属性，如果需要配置多个有两种方式： 1tags: [tag1, tag2, tag3] 或者： 1234tags: - tag1 - tag2 - tag3 标题标题分为五级，依次字号变小 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表无序列表写法： 123* 无序列表项1+ 无序列表项2- 无序列表项3 效果： 无序列表项1 无序列表项2 无序列表项3 有序列表写法： 1231.有序列表项12.有序列表项23.有序列表项3 效果：1.有序列表项12.有序列表项23.有序列表项3 斜体与粗体写法： 1234*这是斜体* 或 _这也是斜体_ **这是粗体*****这是加粗斜体***~~这是删除线~~ 效果： 这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 超链接写法： 12345行内形式：[我的博客](https://xu-yh.github.io/)参考形式：[我的博客][1]，[我的github][2][1]:https://xu-yh.github.io/[2]:https://github.com/XU-YH自动链接：我的博客地址&lt;https://xu-yh.github.io/&gt; 效果： 行内形式：我的博客参考形式：[我的博客][1]，[我的github][2][1]:https://xu-yh.github.io/[2]:https://github.com/XU-YH自动链接：我的博客地址https://xu-yh.github.io/ 表格写法： 12345| 表头1| 表头2| 表头3| 表头4| -| :- | :-: | -: || 默认左对齐| 左对齐| 居中对其| 右对齐|| 默认左对齐| 左对齐| 居中对其| 右对齐|| 默认左对齐| 左对齐| 居中对其| 右对齐| 效果： 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 插入图片写法： 12![](/images/insert_image.jpg)这里的地址可以使本地地址，也可以是图片网址 效果： 引用写法： 1&gt; 这是引用 效果： 这是引用 分割线写法： 123---***三个-或* 效果： 需要注意的是：标记与内容之间必须空一行隔开 结语 这篇文章写了有两个多小时了，结果是值得的，从网上摘抄过来的知识，自己整理出来，收获很多，掌握了markdown的基本语法，下次写文章会轻松很多吧！ 第一次写文章有什么错误和意见希望在下方留言告诉我，大佬教教我。 参考文章地址： 如何写一篇hexo博客 用Hexo写出第一篇博客]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
